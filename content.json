{"meta":{"title":"nymph's blog","subtitle":"","description":"","author":"m-ling","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-06-10T09:12:05.558Z","updated":"2020-06-10T09:12:05.558Z","comments":true,"path":"love.js","permalink":"http://yoursite.com/love.js","excerpt":"","text":"! function (e, t, a) { function n() { c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r() } function r() { for (var e = 0; e < d.length; e++) d[e].alpha"},{"title":"标签","date":"2020-06-01T09:12:37.000Z","updated":"2020-06-12T07:01:08.762Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/","excerpt":"","text":""},{"title":"留个爪印~~","date":"2020-06-01T09:23:40.000Z","updated":"2020-06-10T08:37:47.311Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/","excerpt":"","text":""}],"posts":[{"title":"yibu","slug":"yibu","date":"2020-06-12T07:57:54.000Z","updated":"2020-06-12T07:57:54.642Z","comments":true,"path":"2020/06/12/yibu/","link":"","permalink":"http://yoursite.com/2020/06/12/yibu/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"js引擎的执行机制---event","slug":"EventLoop","date":"2020-06-12T03:56:57.000Z","updated":"2020-06-12T06:58:21.638Z","comments":true,"path":"2020/06/12/EventLoop/","link":"","permalink":"http://yoursite.com/2020/06/12/EventLoop/","excerpt":"","text":"首先我们先来思考几个问题： 为什么 js 是单线程？ 为什么需要异步？异步又是如何实现的？ 什么是事件循环（Event Loop）? 一、js 为什么是单线程&emsp; &emsp;Javascript 作为一种浏览器脚本语言，它需要操作 DOM，如果它是多线程语言，那将会出现很多复杂的问题。我们可以想象一下，如果 js 有两个线程，在同一时间，一个线程修改了某个 DOM 节点，而另一个线程删除了这个 DOM 节点，那么浏览器应该听谁的话呢？所以 js 单线程的特性基本没有改变的可能性。&emsp; &emsp; 随着现在 CPU 的性能增强，单线程无法充分发挥计算机的计算能力。H5 提供了 Web Worker 标准，为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。但子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 二、为什么需要异步以及异步的实现 &emsp; &emsp; “同步模式”就是程序从上到下按顺序执行，后一个任务等待前一个任务结束，然后再执行。如果前任务耗时很长，后面的任务都必须排队等着，这样就会拖延整个程序的执行。后面的代码就会被阻塞。对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验。&emsp; &emsp; “异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。 异步的处理方式有（后一篇文章中会详细讲述）： 回调函数（易形成回调地狱，避免使用） 事件监听 promise Generator 函数 优雅的 async/await 三、Event Loop 上图是事件循环示意图，具体流程如下： 主线程顺序执行代码，形成相应的堆和栈。 主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）。 异步任务处理完成，将相应的异步任务推入任务队列。 主线任务执行完毕，查询任务队列，如果存在任务，就取出一个任务推入主线程（先进先出）。 以上四个步骤循环执行，就形成了事件循环。 宏任务和微任务 js 引擎将所有任务分为宏任务和微任务宏任务：setTimeout，setInterval，setImmediate，ajax微任务：process.nextTick，Promise.then 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取） 来看一道面试题帮助理解 (^_^) 12345678910111213141516setTimeout(() =&gt; &#123; console.log('内层宏事件')&#125;, 0)new Promise((resolve) =&gt; &#123; console.log('外层宏事件1') resolve()&#125;) .then(() =&gt; &#123; console.log('微事件1') &#125;) .then(() =&gt; &#123; console.log('微事件2') &#125;)console.log('外层宏事件2') 浏览器执行 js，遇到 setTimeout 分发宏任务到 Event Queue 中。第一个宏任务进入主线程，直接输出 ’外层宏事件 1‘ ，然后 ‘外层宏事件 2’。执行完后开始执行被分发到微任务队列的 then，执行完所有微任务队列的事件后，开始执行下一个宏任务，输出 ‘内层宏事件’ 123456//正确答案外层宏事件1外层宏事件2微事件1微事件2内层宏事件","categories":[],"tags":[{"name":"js高级","slug":"js高级","permalink":"http://yoursite.com/tags/js%E9%AB%98%E7%BA%A7/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-26T04:12:57.000Z","updated":"2020-06-12T07:04:58.515Z","comments":true,"path":"2017/05/26/hello-world/","link":"","permalink":"http://yoursite.com/2017/05/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"表格","slug":"表格","permalink":"http://yoursite.com/tags/%E8%A1%A8%E6%A0%BC/"},{"name":"表单验证","slug":"表单验证","permalink":"http://yoursite.com/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"}]}]}